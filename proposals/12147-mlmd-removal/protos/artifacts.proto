syntax = "proto3";

service ArtifactService {
  // Finds all artifacts within the specified namespace.
  // Namespace field is required. In multi-user mode, the caller
  rpc ListArtifacts(ListArtifactRequest) returns (ListArtifactResponse) {
    option (google.api.http) = {
      get: "/apis/v2beta1/artifacts"
    };
  }

  // Finds a specific Artifact by ID.
  rpc GetArtifact(GetArtifactRequest) returns (Artifact) {
    option (google.api.http) = {
      get: "/apis/v2beta1/artifacts/{artifact_id}"
    };
  }

  // Updates an existing artifact.
  rpc UpdateArtifact(UpdateArtifactRequest) returns (Artifact) {
    option (google.api.http) = {
      put: "/apis/v2beta1/artifacts/{artifact.artifact_id}"
      body: "artifact"
    };
  }

  rpc ListArtifactTasks(ListArtifactTasksRequest) returns (ListArtifactTasksResponse) {
    option (google.api.http) = {
      get: "/apis/v2beta1/artifact_tasks"
    };
  }

  // Creates a new artifact.
  rpc CreateArtifact(CreateArtifactRequest) returns (Artifact) {
    option (google.api.http) = {
      post: "/apis/v2beta1/artifacts"
      body: "*"
    };
  }

  // Logs a metric for a specific task.
  rpc LogMetric(LogMetricRequest) returns (Metric) {
    option (google.api.http) = {
      post: "/apis/v2beta1/metrics"
      body: "*"
    };
  }

  // Gets a metric by task ID and name.
  rpc GetMetric(GetMetricRequest) returns (Metric) {
    option (google.api.http) = {
      get: "/apis/v2beta1/metrics/{task_id}/{name}"
    };
  }

  // Lists all metrics.
  rpc ListMetrics(ListMetricsRequest) returns (ListMetricsResponse) {
    option (google.api.http) = {
      get: "/apis/v2beta1/metrics"
    };
  }
}


message CreateArtifactRequest {
  // Required. The artifact to create.
  Artifact artifact = 1;
}

message UpdateArtifactRequest {
  // Required. The artifact to update. The artifact_id field is required.
  Artifact artifact = 1;
}

message GetArtifactRequest {
  // Required. The ID of the artifact to be retrieved.
  string artifact_id = 1;
}

// Note: This follows the same format as other List operations in KFP backend
message ListArtifactRequest {
  // Optional input. Namespace for the artifacts.
  string namespace = 1;

  // A page token to request the results page.
  string page_token = 2;

  // The number of artifacts to be listed per page. If there are more artifacts
  // than this number, the response message will contain a valid value in the
  // nextPageToken field.
  int32 page_size = 3;

  // Sorting order in form of "field_name", "field_name asc" or "field_name desc".
  // Ascending by default.
  string sort_by = 4;

  // A url-encoded, JSON-serialized filter protocol buffer (see
  // [filter.proto](https://github.com/kubeflow/artifacts/blob/master/backend/api/filter.proto)).
  string filter = 5;
}

message ListArtifactResponse {
  // The list of artifacts returned.
  repeated Artifact artifacts = 1;

  // The total number of artifacts available. This field is not always populated.
  int32 total_size = 2;

  // A token to retrieve the next page of results, or empty if there are no
  // more results in the list.
  string next_page_token = 3;
}

// The fields here work the same as previous backend api calls
message ListArtifactTasksRequest {
  // Optional, filter artifact task by a set of task_ids
  // We can also likely just rely on filter for this and omit this field
  repeated string task_ids = 1;
  // Optional input, filter artifact task by a set of run_ids
  repeated string run_ids = 2;
  // Optional, filter artifact task by a set of artifact_ids
  // We can also likely just rely on filter for this and omit this field
  repeated string artifact_ids = 3;
  
  // Optional. Only list artifact tasks that have artifacts of this type.
  ArtifactTasksType type = 4;
  
  string page_token = 5;
  int32 page_size = 6;
  string sort_by = 7;
  string filter = 8;
}

message ListArtifactTasksResponse {
  repeated ArtifactTasks artifact_tasks = 1;
  int32 total_size = 2;
  string next_page_token = 3;
}

message LogMetricRequest {
  // Required. The metric to log.
  Metric metric = 1;
}

message GetMetricRequest {
  // Required. Task UUID that owns this metric
  string task_id = 1;
  // Required. Name of the metric
  string name = 2;
}

message ListMetricsRequest {
  // Optional input, filter metrics by a set of task_ids
  repeated string task_ids = 1;
  // Optional input, filter metrics by a set of run_ids
  repeated string run_ids = 2;
  // Optional input. Namespace for the metrics.
  string namespace = 3;
  // A page token to request the results page.
  string page_token = 4;
  // The number of metrics to be listed per page.
  int32 page_size = 5;
  // Sorting order in form of "field_name", "field_name asc" or "field_name desc".
  string sort_by = 6;
  // A url-encoded, JSON-serialized filter protocol buffer.
  string filter = 7;
}

message ListMetricsResponse {
  // The list of metrics returned.
  repeated Metric metrics = 1;
  // The total number of metrics available.
  int32 total_size = 2;
  // Token to retrieve the next page of results.
  string next_page_token = 3;
}

enum ArtifactTasksType {
  INPUT = 0;
  OUTPUT = 1;
}

message ArtifactTasks {
  string id = 1;
  string artifact_id = 2;
  string task_id = 3;

  ArtifactTasks type = 4;
  google.protobuf.Timestamp created_at = 5;
}

enum MetricType {
  METRIC_INPUT = 0;
  METRIC_OUTPUT = 1;
}

message Metric {
  // Required. Task UUID that owns this metric
  string task_id = 1;
  // Required. Name of the metric
  string name = 2;

  // Required. Schema of the metric
  enum Schema {
    Metric = 0;
    ClassificationMetric = 1;
    SlicedClassificationMetric = 2;
  }
  Schema schema = 3;
  // Value can be double or a valid json,
  // but not string_value, bool_value, null_value
  // API server validation will be needed
  google.protobuf.Value value = 4;
  google.protobuf.Timestamp created_at = 5;
  // Required. Type of the metric (input/output)
  MetricType type = 6;

}

// Note to be confused with RuntimeArtifact in pipelinespec
message Artifact {
  // Output only. The unique server generated id of the artifact.
  // Note: Updated id name to be consistent with other api naming patterns (with prefix)
  string artifact_id = 1;
  // The client provided name of the artifact.
  // Note: it seems in MLMD when name was set, it had to be unique for that type_id
  // this restriction is removed here
  string name = 2;

  enum ArtifactType {
    Artifact = 0;
    Model = 1;
    Dataset = 2;
    HTML = 3;
    Markdown = 4;
  }
  // The name of an ArtifactType. E.g. Dataset
  ArtifactType type = 3;

  // The uniform resource identifier of the physical artifact.
  // May be empty if there is no physical artifact.
  string uri = 4;
  // User provided custom properties which are not defined by its type.
  map<string, Value> metadata = 5;
  // Output only. Create time of the artifact in millisecond since epoch.
  // Note: The type and name is updated from mlmd artifact to be consistent with other backend apis.
  google.protobuf.Timestamp created_at = 6;

  // New field:
  string namespace = 7;

  // In KFP only the Live state is ever used
  // As such we don't port this field over, default assumption is all artifacts are live
  // we can add more states if we need to in the future
  // State state = 8;

  // Fields not included from mlmd artifact are: state, external_id, properties, system_metadata, last_update_time_since_epoch, type_id
  // Reference: https://raw.githubusercontent.com/kubeflow/pipelines/refs/heads/master/third_party/ml-metadata/ml_metadata/proto/metadata_store.proto
}
