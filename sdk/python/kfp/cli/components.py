# Copyright 2021 The Kubeflow Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import kfp
from pathlib import Path
from typing import Any, Optional

import docker
import typer

_REQUIREMENTS_TXT = 'requirements.txt'

_DOCKERFILE = 'Dockerfile'

_DOCKERFILE_TEMPLATE = '''
FROM {base_image}

WORKDIR /src/kfp/components
RUN pip install --no-cache-dir kfp=={kfp_version}
COPY requirements.txt requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

COPY . .
'''

_DOCKERIGNORE = '.dockerignore'

_DOCKERIGNORE_TEMPLATE = '''
component_metadata/
'''


def _info(message: Any):
    info = typer.style('INFO', fg=typer.colors.GREEN)
    typer.echo('{}: {}'.format(info, message))


def _warning(message: Any):
    info = typer.style('WARNING', fg=typer.colors.YELLOW)
    typer.echo('{}: {}'.format(info, message))


def _error(message: Any):
    info = typer.style('ERROR', fg=typer.colors.RED)
    typer.echo('{}: {}'.format(info, message))


# def _write_dockerfile(output_dockerfile: Path, base_image: str, target,
#                       image: str, component_module_dir: str, kfp_version: str):
#     dockerfile_contents = _DOCKER_FILE_TEMPLATE.format(
#         base_image=base_image,
#         kfp_version=kfp_version,
#         component_module_dir=component_module_dir)

#     with open(output_dockerfile, 'w') as f:
#         f.write(dockerfile_contents)


class _ComponentBuilder():

    def __init__(self, context_directory: Path, build_directory: Path,
                 base_image: str, target_image: str, kfp_version: str):
        self._context_directory = context_directory
        self._build_directory = build_directory
        self._base_image = base_image
        self._target_image = target_image
        self._kfp_version = kfp_version
        self._dockerfile = self._context_directory / _DOCKERFILE

        self._files = [
            file.name for file in context_directory.glob('*') if file.is_file()
        ]

    def _maybe_write_file(self, filename: str, contents: str):
        formatted_filename = typer.style(filename, fg=typer.colors.CYAN)
        if filename in self._files:
            _info('Found existing file {} under {}. Leaving this untouched.'.
                  format(formatted_filename, self._context_directory))
            return

        _warning('{} not found under {}. Creating one.'.format(
            formatted_filename, self._context_directory))

        filepath = self._context_directory / filename
        with open(filepath, 'w') as f:
            f.write('# Generated by KFP.\n{}'.format(contents))
        _info('Generated file {}.'.format(filepath))

    def maybe_generate_requirements_txt(self):
        self._maybe_write_file(_REQUIREMENTS_TXT, '')

    def maybe_generate_dockerignore(self):
        self._maybe_write_file(_DOCKERIGNORE, _DOCKERIGNORE_TEMPLATE)

    def maybe_generate_dockerfile(self):
        dockerfile_contents = _DOCKERFILE_TEMPLATE.format(
            base_image=self._base_image, kfp_version=self._kfp_version)

        self._maybe_write_file(_DOCKERFILE, dockerfile_contents)

    def build_image(self):
        _info('Building image {} using Docker...'.format(
            typer.style(self._target_image, fg=typer.colors.YELLOW)))
        client = docker.from_env()

        def _print_logs(logs, print_fn):
            log_prefix = typer.style('Docker: ', fg=typer.colors.CYAN)
            for log in logs:
                message = log.get('stream', '').rstrip('\n')
                if not message:
                    continue

                print_fn(log_prefix + message)

        try:
            self._image, logs = client.images.build(path=str(
                self._context_directory),
                                                    dockerfile='Dockerfile',
                                                    tag=self._target_image)
        except docker.errors.BuildError as e:
            _print_logs(e.build_log, _error)
            raise e

        _print_logs(logs, _info)

    # except Exception as e:
    #     print('ERRR: ', e)


app = typer.Typer()


@app.callback()
def components():
    """Builds shareable, containerized components."""
    pass


import enum


class Engine(str, enum.Enum):
    DOCKER = 'docker'
    KANIKO = 'kaniko'


@app.command()
def build(
    component_module: Path = typer.Argument(..., help='Path to file'),
    component_metadata: str = 'component.yaml',
    dockerfile: str = 'Dockerfile',
    requirements_file: str = 'requirements.txt',
    build_engine: Engine = Engine.DOCKER,
):
    """
    Build
    """
    component_module = component_module.resolve()
    _info(component_module.absolute())
    docker_context_dir = component_module.parent
    _warning(docker_context_dir)
    build_directory = docker_context_dir / 'metadata'
    _error(build_directory)

    base_image = 'python:3.7-slim'
    target_image = 'gcr.io/ajay-aiplatform/containerized-kfp'

    builder = _ComponentBuilder(context_directory=docker_context_dir,
                                build_directory=build_directory,
                                base_image=base_image,
                                target_image=target_image,
                                kfp_version=kfp.__version__)

    builder.maybe_generate_requirements_txt()
    builder.maybe_generate_dockerignore()
    builder.maybe_generate_dockerfile()
    builder.build_image()


if __name__ == '__main__':
    app()

# @component.command()
# @click.option(
#     '-o',)
# def build():
#     pass