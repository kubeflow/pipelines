/* tslint:disable */
/* eslint-disable */
/**
 * backend/api/v2beta1/recurring_run.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import {
  GooglerpcStatus,
  V2beta1ListRecurringRunsResponse,
  V2beta1RecurringRun,
} from '../models/index';
import {
  GooglerpcStatusFromJSON,
  GooglerpcStatusToJSON,
  V2beta1ListRecurringRunsResponseFromJSON,
  V2beta1ListRecurringRunsResponseToJSON,
  V2beta1RecurringRunFromJSON,
  V2beta1RecurringRunToJSON,
} from '../models/index';

export interface CreateRecurringRunRequest {
  recurring_run: Omit<V2beta1RecurringRun, 'namespace'>;
}

export interface DeleteRecurringRunRequest {
  recurring_run_id: string;
  propagation_policy?: DeleteRecurringRunPropagationPolicyEnum;
}

export interface DisableRecurringRunRequest {
  recurring_run_id: string;
}

export interface EnableRecurringRunRequest {
  recurring_run_id: string;
}

export interface GetRecurringRunRequest {
  recurring_run_id: string;
}

export interface ListRecurringRunsRequest {
  page_token?: string;
  page_size?: number;
  sort_by?: string;
  namespace?: string;
  filter?: string;
  experiment_id?: string;
}

/**
 *
 */
export class RecurringRunServiceApi extends runtime.BaseAPI {
  /**
   * Creates a new recurring run in an experiment, given the experiment ID.
   */
  async createRecurringRunRaw(
    requestParameters: CreateRecurringRunRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<V2beta1RecurringRun>> {
    if (requestParameters['recurring_run'] == null) {
      throw new runtime.RequiredError(
        'recurring_run',
        'Required parameter "recurring_run" was null or undefined when calling createRecurringRun().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    let urlPath = `/apis/v2beta1/recurringruns`;

    const response = await this.request(
      {
        path: urlPath,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V2beta1RecurringRunToJSON(requestParameters['recurring_run']),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      V2beta1RecurringRunFromJSON(jsonValue),
    );
  }

  /**
   * Creates a new recurring run in an experiment, given the experiment ID.
   */
  async createRecurringRun(
    recurring_run: V2beta1RecurringRun,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<V2beta1RecurringRun> {
    const response = await this.createRecurringRunRaw(
      { recurring_run: recurring_run },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Deletes a recurring run.
   */
  async deleteRecurringRunRaw(
    requestParameters: DeleteRecurringRunRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<object>> {
    if (requestParameters['recurring_run_id'] == null) {
      throw new runtime.RequiredError(
        'recurring_run_id',
        'Required parameter "recurring_run_id" was null or undefined when calling deleteRecurringRun().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters['propagation_policy'] != null) {
      queryParameters['propagation_policy'] = requestParameters['propagation_policy'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    let urlPath = `/apis/v2beta1/recurringruns/{recurring_run_id}`;
    urlPath = urlPath.replace(
      `{${'recurring_run_id'}}`,
      encodeURIComponent(String(requestParameters['recurring_run_id'])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Deletes a recurring run.
   */
  async deleteRecurringRun(
    recurring_run_id: string,
    propagation_policy?: DeleteRecurringRunPropagationPolicyEnum,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<object> {
    const response = await this.deleteRecurringRunRaw(
      { recurring_run_id: recurring_run_id, propagation_policy: propagation_policy },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Stops a recurring run and all its associated runs. The recurring run is not deleted.
   */
  async disableRecurringRunRaw(
    requestParameters: DisableRecurringRunRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<object>> {
    if (requestParameters['recurring_run_id'] == null) {
      throw new runtime.RequiredError(
        'recurring_run_id',
        'Required parameter "recurring_run_id" was null or undefined when calling disableRecurringRun().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    let urlPath = `/apis/v2beta1/recurringruns/{recurring_run_id}:disable`;
    urlPath = urlPath.replace(
      `{${'recurring_run_id'}}`,
      encodeURIComponent(String(requestParameters['recurring_run_id'])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Stops a recurring run and all its associated runs. The recurring run is not deleted.
   */
  async disableRecurringRun(
    recurring_run_id: string,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<object> {
    const response = await this.disableRecurringRunRaw(
      { recurring_run_id: recurring_run_id },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Restarts a recurring run that was previously stopped. All runs associated with the recurring run will continue.
   */
  async enableRecurringRunRaw(
    requestParameters: EnableRecurringRunRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<object>> {
    if (requestParameters['recurring_run_id'] == null) {
      throw new runtime.RequiredError(
        'recurring_run_id',
        'Required parameter "recurring_run_id" was null or undefined when calling enableRecurringRun().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    let urlPath = `/apis/v2beta1/recurringruns/{recurring_run_id}:enable`;
    urlPath = urlPath.replace(
      `{${'recurring_run_id'}}`,
      encodeURIComponent(String(requestParameters['recurring_run_id'])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Restarts a recurring run that was previously stopped. All runs associated with the recurring run will continue.
   */
  async enableRecurringRun(
    recurring_run_id: string,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<object> {
    const response = await this.enableRecurringRunRaw(
      { recurring_run_id: recurring_run_id },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Finds a specific recurring run by ID.
   */
  async getRecurringRunRaw(
    requestParameters: GetRecurringRunRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<V2beta1RecurringRun>> {
    if (requestParameters['recurring_run_id'] == null) {
      throw new runtime.RequiredError(
        'recurring_run_id',
        'Required parameter "recurring_run_id" was null or undefined when calling getRecurringRun().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    let urlPath = `/apis/v2beta1/recurringruns/{recurring_run_id}`;
    urlPath = urlPath.replace(
      `{${'recurring_run_id'}}`,
      encodeURIComponent(String(requestParameters['recurring_run_id'])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      V2beta1RecurringRunFromJSON(jsonValue),
    );
  }

  /**
   * Finds a specific recurring run by ID.
   */
  async getRecurringRun(
    recurring_run_id: string,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<V2beta1RecurringRun> {
    const response = await this.getRecurringRunRaw(
      { recurring_run_id: recurring_run_id },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Finds all recurring runs given experiment and namespace. If experiment ID is not specified, find all recurring runs across all experiments.
   */
  async listRecurringRunsRaw(
    requestParameters: ListRecurringRunsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<V2beta1ListRecurringRunsResponse>> {
    const queryParameters: any = {};

    if (requestParameters['page_token'] != null) {
      queryParameters['page_token'] = requestParameters['page_token'];
    }

    if (requestParameters['page_size'] != null) {
      queryParameters['page_size'] = requestParameters['page_size'];
    }

    if (requestParameters['sort_by'] != null) {
      queryParameters['sort_by'] = requestParameters['sort_by'];
    }

    if (requestParameters['namespace'] != null) {
      queryParameters['namespace'] = requestParameters['namespace'];
    }

    if (requestParameters['filter'] != null) {
      queryParameters['filter'] = requestParameters['filter'];
    }

    if (requestParameters['experiment_id'] != null) {
      queryParameters['experiment_id'] = requestParameters['experiment_id'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    let urlPath = `/apis/v2beta1/recurringruns`;

    const response = await this.request(
      {
        path: urlPath,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      V2beta1ListRecurringRunsResponseFromJSON(jsonValue),
    );
  }

  /**
   * Finds all recurring runs given experiment and namespace. If experiment ID is not specified, find all recurring runs across all experiments.
   */
  async listRecurringRuns(
    page_token?: string,
    page_size?: number,
    sort_by?: string,
    namespace?: string,
    filter?: string,
    experiment_id?: string,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<V2beta1ListRecurringRunsResponse> {
    const response = await this.listRecurringRunsRaw(
      {
        page_token: page_token,
        page_size: page_size,
        sort_by: sort_by,
        namespace: namespace,
        filter: filter,
        experiment_id: experiment_id,
      },
      initOverrides,
    );
    return await response.value();
  }
}

/**
 * @export
 */
export const DeleteRecurringRunPropagationPolicyEnum = {
  DELETE_PROPAGATION_POLICY_UNSPECIFIED: 'DELETE_PROPAGATION_POLICY_UNSPECIFIED',
  FOREGROUND: 'FOREGROUND',
  BACKGROUND: 'BACKGROUND',
  ORPHAN: 'ORPHAN',
} as const;
export type DeleteRecurringRunPropagationPolicyEnum = typeof DeleteRecurringRunPropagationPolicyEnum[keyof typeof DeleteRecurringRunPropagationPolicyEnum];
