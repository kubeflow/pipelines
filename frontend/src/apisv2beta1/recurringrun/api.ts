/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * backend/api/v2beta1/recurring_run.proto
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: version not set
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url';
import * as portableFetch from 'portable-fetch';
import { Configuration } from './configuration';

const BASE_PATH = 'http://localhost'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch,
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 * The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details.  You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
 * @export
 * @interface GooglerpcStatus
 */
export interface GooglerpcStatus {
  /**
   * The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
   * @type {number}
   * @memberof GooglerpcStatus
   */
  code?: number;
  /**
   * A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
   * @type {string}
   * @memberof GooglerpcStatus
   */
  message?: string;
  /**
   * A list of messages that carry the error details.  There is a common set of message types for APIs to use.
   * @type {Array<ProtobufAny>}
   * @memberof GooglerpcStatus
   */
  details?: Array<ProtobufAny>;
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
  /**
   * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
   * @type {string}
   * @memberof ProtobufAny
   */
  type_url?: string;
  /**
   * Must be a valid serialized protocol buffer of the above specified type.
   * @type {string}
   * @memberof ProtobufAny
   */
  value?: string;
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */
export enum ProtobufNullValue {
  NULLVALUE = <any>'NULL_VALUE',
}

/**
 * Required input. User setting to enable or disable the recurring run.  Only used for creation of recurring runs. Later updates use enable/disable API.   - DISABLE: The recurring run won't schedule any run if disabled.
 * @export
 * @enum {string}
 */
export enum RecurringRunMode {
  MODEUNSPECIFIED = <any>'MODE_UNSPECIFIED',
  ENABLE = <any>'ENABLE',
  DISABLE = <any>'DISABLE',
}

/**
 * CronSchedule allow scheduling the recurring run with unix-like cron.
 * @export
 * @interface V2beta1CronSchedule
 */
export interface V2beta1CronSchedule {
  /**
   * The start time of the cron job.
   * @type {Date}
   * @memberof V2beta1CronSchedule
   */
  start_time?: Date;
  /**
   * The end time of the cron job.
   * @type {Date}
   * @memberof V2beta1CronSchedule
   */
  end_time?: Date;
  /**
   *
   * @type {string}
   * @memberof V2beta1CronSchedule
   */
  cron?: string;
}

/**
 *
 * @export
 * @interface V2beta1ListRecurringRunsResponse
 */
export interface V2beta1ListRecurringRunsResponse {
  /**
   * A list of recurring runs returned.
   * @type {Array<V2beta1RecurringRun>}
   * @memberof V2beta1ListRecurringRunsResponse
   */
  recurringRuns?: Array<V2beta1RecurringRun>;
  /**
   * The total number of recurring runs for the given query.
   * @type {number}
   * @memberof V2beta1ListRecurringRunsResponse
   */
  total_size?: number;
  /**
   * The token to list the next page of recurring runs.
   * @type {string}
   * @memberof V2beta1ListRecurringRunsResponse
   */
  next_page_token?: string;
}

/**
 * PeriodicSchedule allow scheduling the recurring run periodically with certain interval.
 * @export
 * @interface V2beta1PeriodicSchedule
 */
export interface V2beta1PeriodicSchedule {
  /**
   * The start time of the periodic recurring run.
   * @type {Date}
   * @memberof V2beta1PeriodicSchedule
   */
  start_time?: Date;
  /**
   * The end time of the periodic recurring run.
   * @type {Date}
   * @memberof V2beta1PeriodicSchedule
   */
  end_time?: Date;
  /**
   * The time interval between the starting time of consecutive recurring runs.
   * @type {string}
   * @memberof V2beta1PeriodicSchedule
   */
  interval_second?: string;
}

/**
 * Reference to an existing pipeline version.
 * @export
 * @interface V2beta1PipelineVersionReference
 */
export interface V2beta1PipelineVersionReference {
  /**
   * Input. Required. Unique ID of the parent pipeline.
   * @type {string}
   * @memberof V2beta1PipelineVersionReference
   */
  pipeline_id?: string;
  /**
   * Input. Required. Unique ID of an existing pipeline version.
   * @type {string}
   * @memberof V2beta1PipelineVersionReference
   */
  pipeline_version_id?: string;
}

/**
 *
 * @export
 * @interface V2beta1RecurringRun
 */
export interface V2beta1RecurringRun {
  /**
   * Output. Unique run ID generated by API server.
   * @type {string}
   * @memberof V2beta1RecurringRun
   */
  recurring_run_id?: string;
  /**
   * Required input field. Recurring run name provided by user. Not unique.
   * @type {string}
   * @memberof V2beta1RecurringRun
   */
  display_name?: string;
  /**
   * Optional input field. Describes the purpose of the recurring run.
   * @type {string}
   * @memberof V2beta1RecurringRun
   */
  description?: string;
  /**
   * The ID of the pipeline version used for creating runs.
   * @type {string}
   * @memberof V2beta1RecurringRun
   */
  pipeline_version_id?: string;
  /**
   * The pipeline spec.
   * @type {any}
   * @memberof V2beta1RecurringRun
   */
  pipeline_spec?: any;
  /**
   * Reference to a pipeline version containing pipeline_id and pipeline_version_id.
   * @type {V2beta1PipelineVersionReference}
   * @memberof V2beta1RecurringRun
   */
  pipeline_version_reference?: V2beta1PipelineVersionReference;
  /**
   * Runtime config of the pipeline.
   * @type {V2beta1RuntimeConfig}
   * @memberof V2beta1RecurringRun
   */
  runtime_config?: V2beta1RuntimeConfig;
  /**
   * Optional input field. Specifies which Kubernetes service account this recurring run uses.
   * @type {string}
   * @memberof V2beta1RecurringRun
   */
  service_account?: string;
  /**
   * Required input field. Specifies how many runs can be executed concurrently. Range [1-10].
   * @type {string}
   * @memberof V2beta1RecurringRun
   */
  max_concurrency?: string;
  /**
   * Required input field. Specifies how a run is triggered. Support cron mode or periodic mode.
   * @type {V2beta1Trigger}
   * @memberof V2beta1RecurringRun
   */
  trigger?: V2beta1Trigger;
  /**
   *
   * @type {RecurringRunMode}
   * @memberof V2beta1RecurringRun
   */
  mode?: RecurringRunMode;
  /**
   * Output. The time this recurring run was created.
   * @type {Date}
   * @memberof V2beta1RecurringRun
   */
  created_at?: Date;
  /**
   * Output. The last time this recurring run was updated.
   * @type {Date}
   * @memberof V2beta1RecurringRun
   */
  updated_at?: Date;
  /**
   *
   * @type {V2beta1RecurringRunStatus}
   * @memberof V2beta1RecurringRun
   */
  status?: V2beta1RecurringRunStatus;
  /**
   * In case any error happens retrieving a recurring run field, only recurring run ID and the error message is returned. Client has the flexibility of choosing how to handle the error. This is especially useful during listing call.
   * @type {GooglerpcStatus}
   * @memberof V2beta1RecurringRun
   */
  error?: GooglerpcStatus;
  /**
   * Optional input field. Whether the recurring run should catch up if behind schedule. If true, the recurring run will only schedule the latest interval if behind schedule. If false, the recurring run will catch up on each past interval.
   * @type {boolean}
   * @memberof V2beta1RecurringRun
   */
  no_catchup?: boolean;
  /**
   * TODO (gkclat): consider removing this field if it can be obtained from the parent experiment. Output only. Namespace this recurring run belongs to. Derived from the parent experiment.
   * @type {string}
   * @memberof V2beta1RecurringRun
   */
  namespace?: string;
  /**
   * ID of the parent experiment this recurring run belongs to.
   * @type {string}
   * @memberof V2beta1RecurringRun
   */
  experiment_id?: string;
}

/**
 * Output. The status of the recurring run.
 * @export
 * @enum {string}
 */
export enum V2beta1RecurringRunStatus {
  STATUSUNSPECIFIED = <any>'STATUS_UNSPECIFIED',
  ENABLED = <any>'ENABLED',
  DISABLED = <any>'DISABLED',
}

/**
 * The runtime config.
 * @export
 * @interface V2beta1RuntimeConfig
 */
export interface V2beta1RuntimeConfig {
  /**
   * The runtime parameters of the Pipeline. The parameters will be used to replace the placeholders at runtime.
   * @type {{ [key: string]: any; }}
   * @memberof V2beta1RuntimeConfig
   */
  parameters?: { [key: string]: any };
  /**
   *
   * @type {string}
   * @memberof V2beta1RuntimeConfig
   */
  pipeline_root?: string;
}

/**
 * Trigger defines what starts a pipeline run.
 * @export
 * @interface V2beta1Trigger
 */
export interface V2beta1Trigger {
  /**
   *
   * @type {V2beta1CronSchedule}
   * @memberof V2beta1Trigger
   */
  cron_schedule?: V2beta1CronSchedule;
  /**
   *
   * @type {V2beta1PeriodicSchedule}
   * @memberof V2beta1Trigger
   */
  periodic_schedule?: V2beta1PeriodicSchedule;
}

/**
 * RecurringRunServiceApi - fetch parameter creator
 * @export
 */
export const RecurringRunServiceApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Creates a new recurring run in an experiment, given the experiment ID.
     * @param {V2beta1RecurringRun} body The recurring run to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRecurringRun(body: V2beta1RecurringRun, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createRecurringRun.',
        );
      }
      const localVarPath = `/apis/v2beta1/recurringruns`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'V2beta1RecurringRun' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a recurring run.
     * @param {string} recurring_run_id The ID of the recurring run to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecurringRun(recurring_run_id: string, options: any = {}): FetchArgs {
      // verify required parameter 'recurring_run_id' is not null or undefined
      if (recurring_run_id === null || recurring_run_id === undefined) {
        throw new RequiredError(
          'recurring_run_id',
          'Required parameter recurring_run_id was null or undefined when calling deleteRecurringRun.',
        );
      }
      const localVarPath = `/apis/v2beta1/recurringruns/{recurring_run_id}`.replace(
        `{${'recurring_run_id'}}`,
        encodeURIComponent(String(recurring_run_id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Stops a recurring run and all its associated runs. The recurring run is not deleted.
     * @param {string} recurring_run_id The ID of the recurring runs to be disabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableRecurringRun(recurring_run_id: string, options: any = {}): FetchArgs {
      // verify required parameter 'recurring_run_id' is not null or undefined
      if (recurring_run_id === null || recurring_run_id === undefined) {
        throw new RequiredError(
          'recurring_run_id',
          'Required parameter recurring_run_id was null or undefined when calling disableRecurringRun.',
        );
      }
      const localVarPath = `/apis/v2beta1/recurringruns/{recurring_run_id}:disable`.replace(
        `{${'recurring_run_id'}}`,
        encodeURIComponent(String(recurring_run_id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Restarts a recurring run that was previously stopped. All runs associated with the  recurring run will continue.
     * @param {string} recurring_run_id The ID of the recurring runs to be enabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableRecurringRun(recurring_run_id: string, options: any = {}): FetchArgs {
      // verify required parameter 'recurring_run_id' is not null or undefined
      if (recurring_run_id === null || recurring_run_id === undefined) {
        throw new RequiredError(
          'recurring_run_id',
          'Required parameter recurring_run_id was null or undefined when calling enableRecurringRun.',
        );
      }
      const localVarPath = `/apis/v2beta1/recurringruns/{recurring_run_id}:enable`.replace(
        `{${'recurring_run_id'}}`,
        encodeURIComponent(String(recurring_run_id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Finds a specific recurring run by ID.
     * @param {string} recurring_run_id The ID of the recurring run to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecurringRun(recurring_run_id: string, options: any = {}): FetchArgs {
      // verify required parameter 'recurring_run_id' is not null or undefined
      if (recurring_run_id === null || recurring_run_id === undefined) {
        throw new RequiredError(
          'recurring_run_id',
          'Required parameter recurring_run_id was null or undefined when calling getRecurringRun.',
        );
      }
      const localVarPath = `/apis/v2beta1/recurringruns/{recurring_run_id}`.replace(
        `{${'recurring_run_id'}}`,
        encodeURIComponent(String(recurring_run_id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Finds all recurring runs given experiment and namespace.  If experiment ID is not specified, find all recurring runs across all experiments.
     * @param {string} [page_token] A page token to request the next page of results. The token is acquired from the nextPageToken field of the response from the previous ListRecurringRuns call or can be omitted when fetching the first page.
     * @param {number} [page_size] The number of recurring runs to be listed per page. If there are more recurring runs  than this number, the response message will contain a nextPageToken field you can use to fetch the next page.
     * @param {string} [sort_by] Can be formatted as \&quot;field_name\&quot;, \&quot;field_name asc\&quot; or \&quot;field_name desc\&quot;. Ascending by default.
     * @param {string} [namespace] Optional input. The namespace the recurring runs belong to.
     * @param {string} [filter] A url-encoded, JSON-serialized Filter protocol buffer (see [filter.proto](https://github.com/kubeflow/pipelines/blob/master/backend/api/filter.proto)).
     * @param {string} [experiment_id] The ID of the experiment to be retrieved. If empty, list recurring runs across all experiments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRecurringRuns(
      page_token?: string,
      page_size?: number,
      sort_by?: string,
      namespace?: string,
      filter?: string,
      experiment_id?: string,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/apis/v2beta1/recurringruns`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page_token !== undefined) {
        localVarQueryParameter['page_token'] = page_token;
      }

      if (page_size !== undefined) {
        localVarQueryParameter['page_size'] = page_size;
      }

      if (sort_by !== undefined) {
        localVarQueryParameter['sort_by'] = sort_by;
      }

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace;
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (experiment_id !== undefined) {
        localVarQueryParameter['experiment_id'] = experiment_id;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RecurringRunServiceApi - functional programming interface
 * @export
 */
export const RecurringRunServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Creates a new recurring run in an experiment, given the experiment ID.
     * @param {V2beta1RecurringRun} body The recurring run to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRecurringRun(
      body: V2beta1RecurringRun,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2beta1RecurringRun> {
      const localVarFetchArgs = RecurringRunServiceApiFetchParamCreator(
        configuration,
      ).createRecurringRun(body, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Deletes a recurring run.
     * @param {string} recurring_run_id The ID of the recurring run to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecurringRun(
      recurring_run_id: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = RecurringRunServiceApiFetchParamCreator(
        configuration,
      ).deleteRecurringRun(recurring_run_id, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Stops a recurring run and all its associated runs. The recurring run is not deleted.
     * @param {string} recurring_run_id The ID of the recurring runs to be disabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableRecurringRun(
      recurring_run_id: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = RecurringRunServiceApiFetchParamCreator(
        configuration,
      ).disableRecurringRun(recurring_run_id, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Restarts a recurring run that was previously stopped. All runs associated with the  recurring run will continue.
     * @param {string} recurring_run_id The ID of the recurring runs to be enabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableRecurringRun(
      recurring_run_id: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = RecurringRunServiceApiFetchParamCreator(
        configuration,
      ).enableRecurringRun(recurring_run_id, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Finds a specific recurring run by ID.
     * @param {string} recurring_run_id The ID of the recurring run to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecurringRun(
      recurring_run_id: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2beta1RecurringRun> {
      const localVarFetchArgs = RecurringRunServiceApiFetchParamCreator(
        configuration,
      ).getRecurringRun(recurring_run_id, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Finds all recurring runs given experiment and namespace.  If experiment ID is not specified, find all recurring runs across all experiments.
     * @param {string} [page_token] A page token to request the next page of results. The token is acquired from the nextPageToken field of the response from the previous ListRecurringRuns call or can be omitted when fetching the first page.
     * @param {number} [page_size] The number of recurring runs to be listed per page. If there are more recurring runs  than this number, the response message will contain a nextPageToken field you can use to fetch the next page.
     * @param {string} [sort_by] Can be formatted as \&quot;field_name\&quot;, \&quot;field_name asc\&quot; or \&quot;field_name desc\&quot;. Ascending by default.
     * @param {string} [namespace] Optional input. The namespace the recurring runs belong to.
     * @param {string} [filter] A url-encoded, JSON-serialized Filter protocol buffer (see [filter.proto](https://github.com/kubeflow/pipelines/blob/master/backend/api/filter.proto)).
     * @param {string} [experiment_id] The ID of the experiment to be retrieved. If empty, list recurring runs across all experiments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRecurringRuns(
      page_token?: string,
      page_size?: number,
      sort_by?: string,
      namespace?: string,
      filter?: string,
      experiment_id?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2beta1ListRecurringRunsResponse> {
      const localVarFetchArgs = RecurringRunServiceApiFetchParamCreator(
        configuration,
      ).listRecurringRuns(
        page_token,
        page_size,
        sort_by,
        namespace,
        filter,
        experiment_id,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * RecurringRunServiceApi - factory interface
 * @export
 */
export const RecurringRunServiceApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Creates a new recurring run in an experiment, given the experiment ID.
     * @param {V2beta1RecurringRun} body The recurring run to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRecurringRun(body: V2beta1RecurringRun, options?: any) {
      return RecurringRunServiceApiFp(configuration).createRecurringRun(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Deletes a recurring run.
     * @param {string} recurring_run_id The ID of the recurring run to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecurringRun(recurring_run_id: string, options?: any) {
      return RecurringRunServiceApiFp(configuration).deleteRecurringRun(recurring_run_id, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Stops a recurring run and all its associated runs. The recurring run is not deleted.
     * @param {string} recurring_run_id The ID of the recurring runs to be disabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableRecurringRun(recurring_run_id: string, options?: any) {
      return RecurringRunServiceApiFp(configuration).disableRecurringRun(recurring_run_id, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Restarts a recurring run that was previously stopped. All runs associated with the  recurring run will continue.
     * @param {string} recurring_run_id The ID of the recurring runs to be enabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableRecurringRun(recurring_run_id: string, options?: any) {
      return RecurringRunServiceApiFp(configuration).enableRecurringRun(recurring_run_id, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Finds a specific recurring run by ID.
     * @param {string} recurring_run_id The ID of the recurring run to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecurringRun(recurring_run_id: string, options?: any) {
      return RecurringRunServiceApiFp(configuration).getRecurringRun(recurring_run_id, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Finds all recurring runs given experiment and namespace.  If experiment ID is not specified, find all recurring runs across all experiments.
     * @param {string} [page_token] A page token to request the next page of results. The token is acquired from the nextPageToken field of the response from the previous ListRecurringRuns call or can be omitted when fetching the first page.
     * @param {number} [page_size] The number of recurring runs to be listed per page. If there are more recurring runs  than this number, the response message will contain a nextPageToken field you can use to fetch the next page.
     * @param {string} [sort_by] Can be formatted as \&quot;field_name\&quot;, \&quot;field_name asc\&quot; or \&quot;field_name desc\&quot;. Ascending by default.
     * @param {string} [namespace] Optional input. The namespace the recurring runs belong to.
     * @param {string} [filter] A url-encoded, JSON-serialized Filter protocol buffer (see [filter.proto](https://github.com/kubeflow/pipelines/blob/master/backend/api/filter.proto)).
     * @param {string} [experiment_id] The ID of the experiment to be retrieved. If empty, list recurring runs across all experiments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRecurringRuns(
      page_token?: string,
      page_size?: number,
      sort_by?: string,
      namespace?: string,
      filter?: string,
      experiment_id?: string,
      options?: any,
    ) {
      return RecurringRunServiceApiFp(configuration).listRecurringRuns(
        page_token,
        page_size,
        sort_by,
        namespace,
        filter,
        experiment_id,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * RecurringRunServiceApi - object-oriented interface
 * @export
 * @class RecurringRunServiceApi
 * @extends {BaseAPI}
 */
export class RecurringRunServiceApi extends BaseAPI {
  /**
   *
   * @summary Creates a new recurring run in an experiment, given the experiment ID.
   * @param {V2beta1RecurringRun} body The recurring run to be created.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringRunServiceApi
   */
  public createRecurringRun(body: V2beta1RecurringRun, options?: any) {
    return RecurringRunServiceApiFp(this.configuration).createRecurringRun(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Deletes a recurring run.
   * @param {string} recurring_run_id The ID of the recurring run to be deleted.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringRunServiceApi
   */
  public deleteRecurringRun(recurring_run_id: string, options?: any) {
    return RecurringRunServiceApiFp(this.configuration).deleteRecurringRun(
      recurring_run_id,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Stops a recurring run and all its associated runs. The recurring run is not deleted.
   * @param {string} recurring_run_id The ID of the recurring runs to be disabled.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringRunServiceApi
   */
  public disableRecurringRun(recurring_run_id: string, options?: any) {
    return RecurringRunServiceApiFp(this.configuration).disableRecurringRun(
      recurring_run_id,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Restarts a recurring run that was previously stopped. All runs associated with the  recurring run will continue.
   * @param {string} recurring_run_id The ID of the recurring runs to be enabled.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringRunServiceApi
   */
  public enableRecurringRun(recurring_run_id: string, options?: any) {
    return RecurringRunServiceApiFp(this.configuration).enableRecurringRun(
      recurring_run_id,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Finds a specific recurring run by ID.
   * @param {string} recurring_run_id The ID of the recurring run to be retrieved.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringRunServiceApi
   */
  public getRecurringRun(recurring_run_id: string, options?: any) {
    return RecurringRunServiceApiFp(this.configuration).getRecurringRun(recurring_run_id, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Finds all recurring runs given experiment and namespace.  If experiment ID is not specified, find all recurring runs across all experiments.
   * @param {string} [page_token] A page token to request the next page of results. The token is acquired from the nextPageToken field of the response from the previous ListRecurringRuns call or can be omitted when fetching the first page.
   * @param {number} [page_size] The number of recurring runs to be listed per page. If there are more recurring runs  than this number, the response message will contain a nextPageToken field you can use to fetch the next page.
   * @param {string} [sort_by] Can be formatted as \&quot;field_name\&quot;, \&quot;field_name asc\&quot; or \&quot;field_name desc\&quot;. Ascending by default.
   * @param {string} [namespace] Optional input. The namespace the recurring runs belong to.
   * @param {string} [filter] A url-encoded, JSON-serialized Filter protocol buffer (see [filter.proto](https://github.com/kubeflow/pipelines/blob/master/backend/api/filter.proto)).
   * @param {string} [experiment_id] The ID of the experiment to be retrieved. If empty, list recurring runs across all experiments.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringRunServiceApi
   */
  public listRecurringRuns(
    page_token?: string,
    page_size?: number,
    sort_by?: string,
    namespace?: string,
    filter?: string,
    experiment_id?: string,
    options?: any,
  ) {
    return RecurringRunServiceApiFp(this.configuration).listRecurringRuns(
      page_token,
      page_size,
      sort_by,
      namespace,
      filter,
      experiment_id,
      options,
    )(this.fetch, this.basePath);
  }
}
