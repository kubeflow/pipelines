/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * backend/api/v2beta1/run.proto
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: version not set
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url';
import * as portableFetch from 'portable-fetch';
import { Configuration } from './configuration';

const BASE_PATH = 'http://localhost'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch,
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 * The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details.  You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
 * @export
 * @interface GooglerpcStatus
 */
export interface GooglerpcStatus {
  /**
   * The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
   * @type {number}
   * @memberof GooglerpcStatus
   */
  code?: number;
  /**
   * A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
   * @type {string}
   * @memberof GooglerpcStatus
   */
  message?: string;
  /**
   * A list of messages that carry the error details.  There is a common set of message types for APIs to use.
   * @type {Array<ProtobufAny>}
   * @memberof GooglerpcStatus
   */
  details?: Array<ProtobufAny>;
}

/**
 * A dependent task that requires this one to succeed. Represented by either task_id or pod_name.
 * @export
 * @interface PipelineTaskDetailChildTask
 */
export interface PipelineTaskDetailChildTask {
  /**
   * System-generated ID of a task.
   * @type {string}
   * @memberof PipelineTaskDetailChildTask
   */
  task_id?: string;
  /**
   * Name of the corresponding pod assigned by the orchestration engine. Also known as node_id.
   * @type {string}
   * @memberof PipelineTaskDetailChildTask
   */
  pod_name?: string;
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
  /**
   * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
   * @type {string}
   * @memberof ProtobufAny
   */
  type_url?: string;
  /**
   * Must be a valid serialized protocol buffer of the above specified type.
   * @type {string}
   * @memberof ProtobufAny
   */
  value?: string;
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */
export enum ProtobufNullValue {
  NULLVALUE = <any>'NULL_VALUE',
}

/**
 * A list of artifact metadata.
 * @export
 * @interface V2beta1ArtifactList
 */
export interface V2beta1ArtifactList {
  /**
   * A list of artifact metadata ids.
   * @type {Array<string>}
   * @memberof V2beta1ArtifactList
   */
  artifact_ids?: Array<string>;
}

/**
 *
 * @export
 * @interface V2beta1ListRunsResponse
 */
export interface V2beta1ListRunsResponse {
  /**
   * List of retrieved runs.
   * @type {Array<V2beta1Run>}
   * @memberof V2beta1ListRunsResponse
   */
  runs?: Array<V2beta1Run>;
  /**
   * The total number of runs for the given query.
   * @type {number}
   * @memberof V2beta1ListRunsResponse
   */
  total_size?: number;
  /**
   * The token to list the next page of runs.
   * @type {string}
   * @memberof V2beta1ListRunsResponse
   */
  next_page_token?: string;
}

/**
 * Runtime information of a task execution.
 * @export
 * @interface V2beta1PipelineTaskDetail
 */
export interface V2beta1PipelineTaskDetail {
  /**
   * ID of the parent run.
   * @type {string}
   * @memberof V2beta1PipelineTaskDetail
   */
  run_id?: string;
  /**
   * System-generated ID of a task.
   * @type {string}
   * @memberof V2beta1PipelineTaskDetail
   */
  task_id?: string;
  /**
   * User specified name of a task that is defined in [Pipeline.spec][].
   * @type {string}
   * @memberof V2beta1PipelineTaskDetail
   */
  display_name?: string;
  /**
   * Creation time of a task.
   * @type {Date}
   * @memberof V2beta1PipelineTaskDetail
   */
  create_time?: Date;
  /**
   * Starting time of a task.
   * @type {Date}
   * @memberof V2beta1PipelineTaskDetail
   */
  start_time?: Date;
  /**
   * Completion time of a task.
   * @type {Date}
   * @memberof V2beta1PipelineTaskDetail
   */
  end_time?: Date;
  /**
   * Execution information of a task.
   * @type {V2beta1PipelineTaskExecutorDetail}
   * @memberof V2beta1PipelineTaskDetail
   */
  executor_detail?: V2beta1PipelineTaskExecutorDetail;
  /**
   * Runtime state of a task.
   * @type {V2beta1RuntimeState}
   * @memberof V2beta1PipelineTaskDetail
   */
  state?: V2beta1RuntimeState;
  /**
   * Execution id of the corresponding entry in ML metadata store.
   * @type {string}
   * @memberof V2beta1PipelineTaskDetail
   */
  execution_id?: string;
  /**
   * The error that occurred during task execution. Only populated when the task is in FAILED or CANCELED state.
   * @type {GooglerpcStatus}
   * @memberof V2beta1PipelineTaskDetail
   */
  error?: GooglerpcStatus;
  /**
   * Input artifacts of the task.
   * @type {{ [key: string]: V2beta1ArtifactList; }}
   * @memberof V2beta1PipelineTaskDetail
   */
  inputs?: { [key: string]: V2beta1ArtifactList };
  /**
   * Output artifacts of the task.
   * @type {{ [key: string]: V2beta1ArtifactList; }}
   * @memberof V2beta1PipelineTaskDetail
   */
  outputs?: { [key: string]: V2beta1ArtifactList };
  /**
   * ID of the parent task if the task is within a component scope. Empty if the task is at the root level.
   * @type {string}
   * @memberof V2beta1PipelineTaskDetail
   */
  parent_task_id?: string;
  /**
   * A sequence of task statuses. This field keeps a record  of state transitions.
   * @type {Array<V2beta1RuntimeStatus>}
   * @memberof V2beta1PipelineTaskDetail
   */
  state_history?: Array<V2beta1RuntimeStatus>;
  /**
   * Name of the corresponding pod assigned by the orchestration engine. Also known as node_id.
   * @type {string}
   * @memberof V2beta1PipelineTaskDetail
   */
  pod_name?: string;
  /**
   * Sequence of dependen tasks.
   * @type {Array<PipelineTaskDetailChildTask>}
   * @memberof V2beta1PipelineTaskDetail
   */
  child_tasks?: Array<PipelineTaskDetailChildTask>;
}

/**
 * Runtime information of a pipeline task executor.
 * @export
 * @interface V2beta1PipelineTaskExecutorDetail
 */
export interface V2beta1PipelineTaskExecutorDetail {
  /**
   * The name of the job for the main container execution.
   * @type {string}
   * @memberof V2beta1PipelineTaskExecutorDetail
   */
  main_job?: string;
  /**
   * The name of the job for the pre-caching-check container execution. This job will be available if the Run.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events.
   * @type {string}
   * @memberof V2beta1PipelineTaskExecutorDetail
   */
  pre_caching_check_job?: string;
  /**
   * The names of the previously failed job for the main container executions. The list includes the all attempts in chronological order.
   * @type {Array<string>}
   * @memberof V2beta1PipelineTaskExecutorDetail
   */
  failed_main_jobs?: Array<string>;
  /**
   * The names of the previously failed job for the pre-caching-check container executions. This job will be available if the Run.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events. The list includes the all attempts in chronological order.
   * @type {Array<string>}
   * @memberof V2beta1PipelineTaskExecutorDetail
   */
  failed_pre_caching_check_jobs?: Array<string>;
}

/**
 * Reference to an existing pipeline version.
 * @export
 * @interface V2beta1PipelineVersionReference
 */
export interface V2beta1PipelineVersionReference {
  /**
   * Input. Required. Unique ID of the parent pipeline.
   * @type {string}
   * @memberof V2beta1PipelineVersionReference
   */
  pipeline_id?: string;
  /**
   * Input. Required. Unique ID of an existing pipeline version.
   * @type {string}
   * @memberof V2beta1PipelineVersionReference
   */
  pipeline_version_id?: string;
}

/**
 *
 * @export
 * @interface V2beta1ReadArtifactResponse
 */
export interface V2beta1ReadArtifactResponse {
  /**
   * Byte array of the artifact content.
   * @type {string}
   * @memberof V2beta1ReadArtifactResponse
   */
  data?: string;
}

/**
 *
 * @export
 * @interface V2beta1Run
 */
export interface V2beta1Run {
  /**
   * Input. ID of the parent experiment. The default experiment ID will be used if this is not specified.
   * @type {string}
   * @memberof V2beta1Run
   */
  experiment_id?: string;
  /**
   * Output. Unique run ID. Generated by API server.
   * @type {string}
   * @memberof V2beta1Run
   */
  run_id?: string;
  /**
   * Required input. Name provided by user, or auto generated if run is created by a recurring run.
   * @type {string}
   * @memberof V2beta1Run
   */
  display_name?: string;
  /**
   * Output. Specifies whether this run is in archived or available mode.
   * @type {V2beta1RunStorageState}
   * @memberof V2beta1Run
   */
  storage_state?: V2beta1RunStorageState;
  /**
   * Optional input. Short description of the run.
   * @type {string}
   * @memberof V2beta1Run
   */
  description?: string;
  /**
   * ID of an existing pipeline version.
   * @type {string}
   * @memberof V2beta1Run
   */
  pipeline_version_id?: string;
  /**
   * Pipeline spec.
   * @type {any}
   * @memberof V2beta1Run
   */
  pipeline_spec?: any;
  /**
   * Reference to a pipeline version containing pipeline_id and pipeline_version_id.
   * @type {V2beta1PipelineVersionReference}
   * @memberof V2beta1Run
   */
  pipeline_version_reference?: V2beta1PipelineVersionReference;
  /**
   * Required input. Runtime config of the run.
   * @type {V2beta1RuntimeConfig}
   * @memberof V2beta1Run
   */
  runtime_config?: V2beta1RuntimeConfig;
  /**
   * Optional input. Specifies which kubernetes service account is used.
   * @type {string}
   * @memberof V2beta1Run
   */
  service_account?: string;
  /**
   * Output. Creation time of the run.
   * @type {Date}
   * @memberof V2beta1Run
   */
  created_at?: Date;
  /**
   * Output. When this run is scheduled to start. This could be different from created_at. For example, if a run is from a backfilling job that was supposed to run 2 month ago, the created_at will be 2 month behind scheduled_at.
   * @type {Date}
   * @memberof V2beta1Run
   */
  scheduled_at?: Date;
  /**
   * Output. Completion of the run.
   * @type {Date}
   * @memberof V2beta1Run
   */
  finished_at?: Date;
  /**
   * Output. Runtime state of a run.
   * @type {V2beta1RuntimeState}
   * @memberof V2beta1Run
   */
  state?: V2beta1RuntimeState;
  /**
   * In case any error happens retrieving a run field, only run ID and the error message is returned. Client has the flexibility of choosing how to handle the error. This is especially useful during listing call.
   * @type {GooglerpcStatus}
   * @memberof V2beta1Run
   */
  error?: GooglerpcStatus;
  /**
   * Output. Runtime details of a run.
   * @type {V2beta1RunDetails}
   * @memberof V2beta1Run
   */
  run_details?: V2beta1RunDetails;
  /**
   * ID of the recurring run that triggered this run.
   * @type {string}
   * @memberof V2beta1Run
   */
  recurring_run_id?: string;
  /**
   * Output. A sequence of run statuses. This field keeps a record  of state transitions.
   * @type {Array<V2beta1RuntimeStatus>}
   * @memberof V2beta1Run
   */
  state_history?: Array<V2beta1RuntimeStatus>;
}

/**
 * Runtime details of a run.
 * @export
 * @interface V2beta1RunDetails
 */
export interface V2beta1RunDetails {
  /**
   * Pipeline context ID of a run.
   * @type {string}
   * @memberof V2beta1RunDetails
   */
  pipeline_context_id?: string;
  /**
   * Pipeline run context ID of a run.
   * @type {string}
   * @memberof V2beta1RunDetails
   */
  pipeline_run_context_id?: string;
  /**
   * Runtime details of the tasks that belong to the run.
   * @type {Array<V2beta1PipelineTaskDetail>}
   * @memberof V2beta1RunDetails
   */
  task_details?: Array<V2beta1PipelineTaskDetail>;
}

/**
 * Describes whether an entity is available or archived.   - STORAGE_STATE_UNSPECIFIED: Default state. This state in not used  - AVAILABLE: Entity is available.  - ARCHIVED: Entity is archived.
 * @export
 * @enum {string}
 */
export enum V2beta1RunStorageState {
  STORAGESTATEUNSPECIFIED = <any>'STORAGE_STATE_UNSPECIFIED',
  AVAILABLE = <any>'AVAILABLE',
  ARCHIVED = <any>'ARCHIVED',
}

/**
 * The runtime config.
 * @export
 * @interface V2beta1RuntimeConfig
 */
export interface V2beta1RuntimeConfig {
  /**
   * The runtime parameters of the Pipeline. The parameters will be used to replace the placeholders at runtime.
   * @type {{ [key: string]: any; }}
   * @memberof V2beta1RuntimeConfig
   */
  parameters?: { [key: string]: any };
  /**
   *
   * @type {string}
   * @memberof V2beta1RuntimeConfig
   */
  pipeline_root?: string;
}

/**
 * Describes the runtime state of an entity.   - RUNTIME_STATE_UNSPECIFIED: Default value. This value is not used.  - PENDING: Service is preparing to execute an entity.  - RUNNING: Entity execution is in progress.  - SUCCEEDED: Entity completed successfully.  - SKIPPED: Entity has been skipped. For example, due to caching.  - FAILED: Entity execution has failed.  - CANCELING: Entity is being canceled. From this state, an entity may only change its state to SUCCEEDED, FAILED or CANCELED.  - CANCELED: Entity has been canceled.  - PAUSED: Entity has been paused. It can be resumed.
 * @export
 * @enum {string}
 */
export enum V2beta1RuntimeState {
  RUNTIMESTATEUNSPECIFIED = <any>'RUNTIME_STATE_UNSPECIFIED',
  PENDING = <any>'PENDING',
  RUNNING = <any>'RUNNING',
  SUCCEEDED = <any>'SUCCEEDED',
  SKIPPED = <any>'SKIPPED',
  FAILED = <any>'FAILED',
  CANCELING = <any>'CANCELING',
  CANCELED = <any>'CANCELED',
  PAUSED = <any>'PAUSED',
}

/**
 * Timestamped representation of a runtime state with an optional error.
 * @export
 * @interface V2beta1RuntimeStatus
 */
export interface V2beta1RuntimeStatus {
  /**
   * Update time of this state.
   * @type {Date}
   * @memberof V2beta1RuntimeStatus
   */
  update_time?: Date;
  /**
   * The state of a runtime instance.
   * @type {V2beta1RuntimeState}
   * @memberof V2beta1RuntimeStatus
   */
  state?: V2beta1RuntimeState;
  /**
   * The error that occurred during the state. May be set when the state is any of the non-final states (PENDING/RUNNING/CANCELING) or FAILED state. If the state is FAILED, the error here is final and not going to be retried. If the state is a non-final state, the error indicates that a  system-error being retried.
   * @type {GooglerpcStatus}
   * @memberof V2beta1RuntimeStatus
   */
  error?: GooglerpcStatus;
}

/**
 * RunServiceApi - fetch parameter creator
 * @export
 */
export const RunServiceApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Archives a run in an experiment given by run ID and experiment ID.
     * @param {string} run_id The ID of the run to be archived.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveRun(run_id: string, options: any = {}): FetchArgs {
      // verify required parameter 'run_id' is not null or undefined
      if (run_id === null || run_id === undefined) {
        throw new RequiredError(
          'run_id',
          'Required parameter run_id was null or undefined when calling archiveRun.',
        );
      }
      const localVarPath = `/apis/v2beta1/runs/{run_id}:archive`.replace(
        `{${'run_id'}}`,
        encodeURIComponent(String(run_id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('authorization')
            : configuration.apiKey;
        localVarHeaderParameter['authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a new run in an experiment specified by experiment ID.  If experiment ID is not specified, the run is created in the default experiment.
     * @param {V2beta1Run} body Run to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRun(body: V2beta1Run, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createRun.',
        );
      }
      const localVarPath = `/apis/v2beta1/runs`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('authorization')
            : configuration.apiKey;
        localVarHeaderParameter['authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'V2beta1Run' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a run in an experiment given by run ID and experiment ID.
     * @param {string} run_id The ID of the run to be deleted.
     * @param {string} [experiment_id] The ID of the parent experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRun(run_id: string, experiment_id?: string, options: any = {}): FetchArgs {
      // verify required parameter 'run_id' is not null or undefined
      if (run_id === null || run_id === undefined) {
        throw new RequiredError(
          'run_id',
          'Required parameter run_id was null or undefined when calling deleteRun.',
        );
      }
      const localVarPath = `/apis/v2beta1/runs/{run_id}`.replace(
        `{${'run_id'}}`,
        encodeURIComponent(String(run_id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('authorization')
            : configuration.apiKey;
        localVarHeaderParameter['authorization'] = localVarApiKeyValue;
      }

      if (experiment_id !== undefined) {
        localVarQueryParameter['experiment_id'] = experiment_id;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Finds a specific run by ID.
     * @param {string} run_id The ID of the run to be retrieved.
     * @param {string} [experiment_id] The ID of the parent experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRun(run_id: string, experiment_id?: string, options: any = {}): FetchArgs {
      // verify required parameter 'run_id' is not null or undefined
      if (run_id === null || run_id === undefined) {
        throw new RequiredError(
          'run_id',
          'Required parameter run_id was null or undefined when calling getRun.',
        );
      }
      const localVarPath = `/apis/v2beta1/runs/{run_id}`.replace(
        `{${'run_id'}}`,
        encodeURIComponent(String(run_id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('authorization')
            : configuration.apiKey;
        localVarHeaderParameter['authorization'] = localVarApiKeyValue;
      }

      if (experiment_id !== undefined) {
        localVarQueryParameter['experiment_id'] = experiment_id;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Finds all runs in an experiment given by experiment ID.  If experiment id is not specified, finds all runs across all experiments.
     * @param {string} [namespace] Optional input field. Filters based on the namespace.
     * @param {string} [experiment_id] The ID of the parent experiment. If empty, response includes runs across all experiments.
     * @param {string} [page_token] A page token to request the next page of results. The token is acquired from the nextPageToken field of the response from the previous ListRuns call or can be omitted when fetching the first page.
     * @param {number} [page_size] The number of runs to be listed per page. If there are more runs than this number, the response message will contain a nextPageToken field you can use to fetch the next page.
     * @param {string} [sort_by] Can be format of \&quot;field_name\&quot;, \&quot;field_name asc\&quot; or \&quot;field_name desc\&quot; (Example, \&quot;name asc\&quot; or \&quot;id desc\&quot;). Ascending by default.
     * @param {string} [filter] A url-encoded, JSON-serialized Filter protocol buffer (see [filter.proto](https://github.com/kubeflow/pipelines/blob/master/backend/api/filter.proto)).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRuns(
      namespace?: string,
      experiment_id?: string,
      page_token?: string,
      page_size?: number,
      sort_by?: string,
      filter?: string,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/apis/v2beta1/runs`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('authorization')
            : configuration.apiKey;
        localVarHeaderParameter['authorization'] = localVarApiKeyValue;
      }

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace;
      }

      if (experiment_id !== undefined) {
        localVarQueryParameter['experiment_id'] = experiment_id;
      }

      if (page_token !== undefined) {
        localVarQueryParameter['page_token'] = page_token;
      }

      if (page_size !== undefined) {
        localVarQueryParameter['page_size'] = page_size;
      }

      if (sort_by !== undefined) {
        localVarQueryParameter['sort_by'] = sort_by;
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Finds artifact data in a run.
     * @param {string} run_id ID of the run.
     * @param {string} node_id ID of the running node.
     * @param {string} artifact_name Name of the artifact.
     * @param {string} [experiment_id] The ID of the parent experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readArtifact(
      run_id: string,
      node_id: string,
      artifact_name: string,
      experiment_id?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'run_id' is not null or undefined
      if (run_id === null || run_id === undefined) {
        throw new RequiredError(
          'run_id',
          'Required parameter run_id was null or undefined when calling readArtifact.',
        );
      }
      // verify required parameter 'node_id' is not null or undefined
      if (node_id === null || node_id === undefined) {
        throw new RequiredError(
          'node_id',
          'Required parameter node_id was null or undefined when calling readArtifact.',
        );
      }
      // verify required parameter 'artifact_name' is not null or undefined
      if (artifact_name === null || artifact_name === undefined) {
        throw new RequiredError(
          'artifact_name',
          'Required parameter artifact_name was null or undefined when calling readArtifact.',
        );
      }
      const localVarPath = `/apis/v2beta1/runs/{run_id}/nodes/{node_id}/artifacts/{artifact_name}:read`
        .replace(`{${'run_id'}}`, encodeURIComponent(String(run_id)))
        .replace(`{${'node_id'}}`, encodeURIComponent(String(node_id)))
        .replace(`{${'artifact_name'}}`, encodeURIComponent(String(artifact_name)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('authorization')
            : configuration.apiKey;
        localVarHeaderParameter['authorization'] = localVarApiKeyValue;
      }

      if (experiment_id !== undefined) {
        localVarQueryParameter['experiment_id'] = experiment_id;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Re-initiates a failed or terminated run.
     * @param {string} run_id The ID of the run to be retried.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retryRun(run_id: string, options: any = {}): FetchArgs {
      // verify required parameter 'run_id' is not null or undefined
      if (run_id === null || run_id === undefined) {
        throw new RequiredError(
          'run_id',
          'Required parameter run_id was null or undefined when calling retryRun.',
        );
      }
      const localVarPath = `/apis/v2beta1/runs/{run_id}:retry`.replace(
        `{${'run_id'}}`,
        encodeURIComponent(String(run_id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('authorization')
            : configuration.apiKey;
        localVarHeaderParameter['authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Terminates an active run.
     * @param {string} run_id The ID of the run to be terminated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateRun(run_id: string, options: any = {}): FetchArgs {
      // verify required parameter 'run_id' is not null or undefined
      if (run_id === null || run_id === undefined) {
        throw new RequiredError(
          'run_id',
          'Required parameter run_id was null or undefined when calling terminateRun.',
        );
      }
      const localVarPath = `/apis/v2beta1/runs/{run_id}:terminate`.replace(
        `{${'run_id'}}`,
        encodeURIComponent(String(run_id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('authorization')
            : configuration.apiKey;
        localVarHeaderParameter['authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Restores an archived run in an experiment given by run ID and experiment ID.
     * @param {string} run_id The ID of the run to be restored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unarchiveRun(run_id: string, options: any = {}): FetchArgs {
      // verify required parameter 'run_id' is not null or undefined
      if (run_id === null || run_id === undefined) {
        throw new RequiredError(
          'run_id',
          'Required parameter run_id was null or undefined when calling unarchiveRun.',
        );
      }
      const localVarPath = `/apis/v2beta1/runs/{run_id}:unarchive`.replace(
        `{${'run_id'}}`,
        encodeURIComponent(String(run_id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('authorization')
            : configuration.apiKey;
        localVarHeaderParameter['authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RunServiceApi - functional programming interface
 * @export
 */
export const RunServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Archives a run in an experiment given by run ID and experiment ID.
     * @param {string} run_id The ID of the run to be archived.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveRun(
      run_id: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).archiveRun(
        run_id,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Creates a new run in an experiment specified by experiment ID.  If experiment ID is not specified, the run is created in the default experiment.
     * @param {V2beta1Run} body Run to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRun(
      body: V2beta1Run,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2beta1Run> {
      const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).createRun(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Deletes a run in an experiment given by run ID and experiment ID.
     * @param {string} run_id The ID of the run to be deleted.
     * @param {string} [experiment_id] The ID of the parent experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRun(
      run_id: string,
      experiment_id?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).deleteRun(
        run_id,
        experiment_id,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Finds a specific run by ID.
     * @param {string} run_id The ID of the run to be retrieved.
     * @param {string} [experiment_id] The ID of the parent experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRun(
      run_id: string,
      experiment_id?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2beta1Run> {
      const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).getRun(
        run_id,
        experiment_id,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Finds all runs in an experiment given by experiment ID.  If experiment id is not specified, finds all runs across all experiments.
     * @param {string} [namespace] Optional input field. Filters based on the namespace.
     * @param {string} [experiment_id] The ID of the parent experiment. If empty, response includes runs across all experiments.
     * @param {string} [page_token] A page token to request the next page of results. The token is acquired from the nextPageToken field of the response from the previous ListRuns call or can be omitted when fetching the first page.
     * @param {number} [page_size] The number of runs to be listed per page. If there are more runs than this number, the response message will contain a nextPageToken field you can use to fetch the next page.
     * @param {string} [sort_by] Can be format of \&quot;field_name\&quot;, \&quot;field_name asc\&quot; or \&quot;field_name desc\&quot; (Example, \&quot;name asc\&quot; or \&quot;id desc\&quot;). Ascending by default.
     * @param {string} [filter] A url-encoded, JSON-serialized Filter protocol buffer (see [filter.proto](https://github.com/kubeflow/pipelines/blob/master/backend/api/filter.proto)).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRuns(
      namespace?: string,
      experiment_id?: string,
      page_token?: string,
      page_size?: number,
      sort_by?: string,
      filter?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2beta1ListRunsResponse> {
      const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).listRuns(
        namespace,
        experiment_id,
        page_token,
        page_size,
        sort_by,
        filter,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Finds artifact data in a run.
     * @param {string} run_id ID of the run.
     * @param {string} node_id ID of the running node.
     * @param {string} artifact_name Name of the artifact.
     * @param {string} [experiment_id] The ID of the parent experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readArtifact(
      run_id: string,
      node_id: string,
      artifact_name: string,
      experiment_id?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2beta1ReadArtifactResponse> {
      const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).readArtifact(
        run_id,
        node_id,
        artifact_name,
        experiment_id,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Re-initiates a failed or terminated run.
     * @param {string} run_id The ID of the run to be retried.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retryRun(run_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).retryRun(
        run_id,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Terminates an active run.
     * @param {string} run_id The ID of the run to be terminated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateRun(
      run_id: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).terminateRun(
        run_id,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Restores an archived run in an experiment given by run ID and experiment ID.
     * @param {string} run_id The ID of the run to be restored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unarchiveRun(
      run_id: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).unarchiveRun(
        run_id,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * RunServiceApi - factory interface
 * @export
 */
export const RunServiceApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Archives a run in an experiment given by run ID and experiment ID.
     * @param {string} run_id The ID of the run to be archived.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveRun(run_id: string, options?: any) {
      return RunServiceApiFp(configuration).archiveRun(run_id, options)(fetch, basePath);
    },
    /**
     *
     * @summary Creates a new run in an experiment specified by experiment ID.  If experiment ID is not specified, the run is created in the default experiment.
     * @param {V2beta1Run} body Run to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRun(body: V2beta1Run, options?: any) {
      return RunServiceApiFp(configuration).createRun(body, options)(fetch, basePath);
    },
    /**
     *
     * @summary Deletes a run in an experiment given by run ID and experiment ID.
     * @param {string} run_id The ID of the run to be deleted.
     * @param {string} [experiment_id] The ID of the parent experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRun(run_id: string, experiment_id?: string, options?: any) {
      return RunServiceApiFp(configuration).deleteRun(
        run_id,
        experiment_id,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Finds a specific run by ID.
     * @param {string} run_id The ID of the run to be retrieved.
     * @param {string} [experiment_id] The ID of the parent experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRun(run_id: string, experiment_id?: string, options?: any) {
      return RunServiceApiFp(configuration).getRun(run_id, experiment_id, options)(fetch, basePath);
    },
    /**
     *
     * @summary Finds all runs in an experiment given by experiment ID.  If experiment id is not specified, finds all runs across all experiments.
     * @param {string} [namespace] Optional input field. Filters based on the namespace.
     * @param {string} [experiment_id] The ID of the parent experiment. If empty, response includes runs across all experiments.
     * @param {string} [page_token] A page token to request the next page of results. The token is acquired from the nextPageToken field of the response from the previous ListRuns call or can be omitted when fetching the first page.
     * @param {number} [page_size] The number of runs to be listed per page. If there are more runs than this number, the response message will contain a nextPageToken field you can use to fetch the next page.
     * @param {string} [sort_by] Can be format of \&quot;field_name\&quot;, \&quot;field_name asc\&quot; or \&quot;field_name desc\&quot; (Example, \&quot;name asc\&quot; or \&quot;id desc\&quot;). Ascending by default.
     * @param {string} [filter] A url-encoded, JSON-serialized Filter protocol buffer (see [filter.proto](https://github.com/kubeflow/pipelines/blob/master/backend/api/filter.proto)).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRuns(
      namespace?: string,
      experiment_id?: string,
      page_token?: string,
      page_size?: number,
      sort_by?: string,
      filter?: string,
      options?: any,
    ) {
      return RunServiceApiFp(configuration).listRuns(
        namespace,
        experiment_id,
        page_token,
        page_size,
        sort_by,
        filter,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Finds artifact data in a run.
     * @param {string} run_id ID of the run.
     * @param {string} node_id ID of the running node.
     * @param {string} artifact_name Name of the artifact.
     * @param {string} [experiment_id] The ID of the parent experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readArtifact(
      run_id: string,
      node_id: string,
      artifact_name: string,
      experiment_id?: string,
      options?: any,
    ) {
      return RunServiceApiFp(configuration).readArtifact(
        run_id,
        node_id,
        artifact_name,
        experiment_id,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Re-initiates a failed or terminated run.
     * @param {string} run_id The ID of the run to be retried.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retryRun(run_id: string, options?: any) {
      return RunServiceApiFp(configuration).retryRun(run_id, options)(fetch, basePath);
    },
    /**
     *
     * @summary Terminates an active run.
     * @param {string} run_id The ID of the run to be terminated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateRun(run_id: string, options?: any) {
      return RunServiceApiFp(configuration).terminateRun(run_id, options)(fetch, basePath);
    },
    /**
     *
     * @summary Restores an archived run in an experiment given by run ID and experiment ID.
     * @param {string} run_id The ID of the run to be restored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unarchiveRun(run_id: string, options?: any) {
      return RunServiceApiFp(configuration).unarchiveRun(run_id, options)(fetch, basePath);
    },
  };
};

/**
 * RunServiceApi - object-oriented interface
 * @export
 * @class RunServiceApi
 * @extends {BaseAPI}
 */
export class RunServiceApi extends BaseAPI {
  /**
   *
   * @summary Archives a run in an experiment given by run ID and experiment ID.
   * @param {string} run_id The ID of the run to be archived.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunServiceApi
   */
  public archiveRun(run_id: string, options?: any) {
    return RunServiceApiFp(this.configuration).archiveRun(run_id, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Creates a new run in an experiment specified by experiment ID.  If experiment ID is not specified, the run is created in the default experiment.
   * @param {V2beta1Run} body Run to be created.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunServiceApi
   */
  public createRun(body: V2beta1Run, options?: any) {
    return RunServiceApiFp(this.configuration).createRun(body, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Deletes a run in an experiment given by run ID and experiment ID.
   * @param {string} run_id The ID of the run to be deleted.
   * @param {string} [experiment_id] The ID of the parent experiment.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunServiceApi
   */
  public deleteRun(run_id: string, experiment_id?: string, options?: any) {
    return RunServiceApiFp(this.configuration).deleteRun(
      run_id,
      experiment_id,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Finds a specific run by ID.
   * @param {string} run_id The ID of the run to be retrieved.
   * @param {string} [experiment_id] The ID of the parent experiment.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunServiceApi
   */
  public getRun(run_id: string, experiment_id?: string, options?: any) {
    return RunServiceApiFp(this.configuration).getRun(
      run_id,
      experiment_id,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Finds all runs in an experiment given by experiment ID.  If experiment id is not specified, finds all runs across all experiments.
   * @param {string} [namespace] Optional input field. Filters based on the namespace.
   * @param {string} [experiment_id] The ID of the parent experiment. If empty, response includes runs across all experiments.
   * @param {string} [page_token] A page token to request the next page of results. The token is acquired from the nextPageToken field of the response from the previous ListRuns call or can be omitted when fetching the first page.
   * @param {number} [page_size] The number of runs to be listed per page. If there are more runs than this number, the response message will contain a nextPageToken field you can use to fetch the next page.
   * @param {string} [sort_by] Can be format of \&quot;field_name\&quot;, \&quot;field_name asc\&quot; or \&quot;field_name desc\&quot; (Example, \&quot;name asc\&quot; or \&quot;id desc\&quot;). Ascending by default.
   * @param {string} [filter] A url-encoded, JSON-serialized Filter protocol buffer (see [filter.proto](https://github.com/kubeflow/pipelines/blob/master/backend/api/filter.proto)).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunServiceApi
   */
  public listRuns(
    namespace?: string,
    experiment_id?: string,
    page_token?: string,
    page_size?: number,
    sort_by?: string,
    filter?: string,
    options?: any,
  ) {
    return RunServiceApiFp(this.configuration).listRuns(
      namespace,
      experiment_id,
      page_token,
      page_size,
      sort_by,
      filter,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Finds artifact data in a run.
   * @param {string} run_id ID of the run.
   * @param {string} node_id ID of the running node.
   * @param {string} artifact_name Name of the artifact.
   * @param {string} [experiment_id] The ID of the parent experiment.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunServiceApi
   */
  public readArtifact(
    run_id: string,
    node_id: string,
    artifact_name: string,
    experiment_id?: string,
    options?: any,
  ) {
    return RunServiceApiFp(this.configuration).readArtifact(
      run_id,
      node_id,
      artifact_name,
      experiment_id,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Re-initiates a failed or terminated run.
   * @param {string} run_id The ID of the run to be retried.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunServiceApi
   */
  public retryRun(run_id: string, options?: any) {
    return RunServiceApiFp(this.configuration).retryRun(run_id, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Terminates an active run.
   * @param {string} run_id The ID of the run to be terminated.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunServiceApi
   */
  public terminateRun(run_id: string, options?: any) {
    return RunServiceApiFp(this.configuration).terminateRun(run_id, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Restores an archived run in an experiment given by run ID and experiment ID.
   * @param {string} run_id The ID of the run to be restored.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunServiceApi
   */
  public unarchiveRun(run_id: string, options?: any) {
    return RunServiceApiFp(this.configuration).unarchiveRun(run_id, options)(
      this.fetch,
      this.basePath,
    );
  }
}
