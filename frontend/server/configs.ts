// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as path from 'path';
import { loadJSON } from './utils';
export const BASEPATH = '/pipeline';
export const apiVersion = 'apis/v1beta1';

export enum Deployments {
  NOT_SPECIFIED = 'NOT_SPECIFIED',
  KUBEFLOW = 'KUBEFLOW',
}

/** converts string to bool */
const as_bool = (value: string) => ['true', '1'].indexOf(value.toLowerCase()) >= 0;

function parseArgs(argv: string[]) {
  if (argv.length < 3) {
    const msg = `\
  Usage: node server.js <static-dir> [port].
         You can specify the API server address using the
         ML_PIPELINE_SERVICE_HOST and ML_PIPELINE_SERVICE_PORT
         env vars.`;
    throw new Error(msg);
  }

  const staticDir = path.resolve(argv[2]);
  const port = parseInt(argv[3] || '3000', 10);
  return { staticDir, port };
}

export function loadConfigs(
  argv: string[],
  env: NodeJS.ProcessEnv | { [key: string]: string },
): IConfigs {
  const { staticDir, port } = parseArgs(argv);
  /** All configurable environment variables can be found here. */
  const {
    /** minio client use these to retrieve minio objects/artifacts */
    MINIO_ACCESS_KEY = 'minio',
    MINIO_SECRET_KEY = 'minio123',
    MINIO_PORT = '9000',
    MINIO_HOST = 'minio-service',
    MINIO_NAMESPACE = 'kubeflow',
    MINIO_SSL = 'false',
    /** minio client use these to retrieve s3 objects/artifacts */
    AWS_ACCESS_KEY_ID,
    AWS_SECRET_ACCESS_KEY,
    /** http/https base URL **/
    HTTP_BASE_URL = '',
    /** http/https fetch with this authorization header key (for example: 'Authorization') */
    HTTP_AUTHORIZATION_KEY = '',
    /** http/https fetch with this authorization header value by default when absent in client request at above key */
    HTTP_AUTHORIZATION_DEFAULT_VALUE = '',
    /** API service will listen to this host */
    ML_PIPELINE_SERVICE_HOST = 'localhost',
    /** API service will listen to this port */
    ML_PIPELINE_SERVICE_PORT = '3001',
    /** path to viewer:tensorboard pod template spec */
    VIEWER_TENSORBOARD_POD_TEMPLATE_SPEC_PATH,
    /** Whether custom visualizations are allowed to be generated by the frontend */
    ALLOW_CUSTOM_VISUALIZATIONS = 'false',
    /** Envoy service will listen to this host */
    METADATA_ENVOY_SERVICE_SERVICE_HOST = 'localhost',
    /** Envoy service will listen to this port */
    METADATA_ENVOY_SERVICE_SERVICE_PORT = '9090',
    /** Is Argo log archive enabled? */
    ARGO_ARCHIVE_LOGS = 'false',
    /** Use minio or s3 client to retrieve archives. */
    ARGO_ARCHIVE_ARTIFACTORY = 'minio',
    /** Bucket to retrive logs from */
    ARGO_ARCHIVE_BUCKETNAME = 'mlpipeline',
    /** Prefix to logs. */
    ARGO_ARCHIVE_PREFIX = 'logs',
    /** Deployment type. */
    DEPLOYMENT: DEPLOYMENT_STR = '',
  } = env;

  return {
    server: {
      apiVersion,
      basePath: BASEPATH,
      deployment:
        DEPLOYMENT_STR.toUpperCase() === 'KUBEFLOW'
          ? Deployments.KUBEFLOW
          : Deployments.NOT_SPECIFIED,
      staticDir,
      port,
    },
    artifacts: {
      minio: {
        accessKey: MINIO_ACCESS_KEY,
        endPoint:
          MINIO_NAMESPACE && MINIO_NAMESPACE.length > 0
            ? `${MINIO_HOST}.${MINIO_NAMESPACE}`
            : MINIO_HOST,
        port: parseInt(MINIO_PORT, 10),
        secretKey: MINIO_SECRET_KEY,
        useSSL: as_bool(MINIO_SSL),
      },
      aws: {
        endPoint: 's3.amazonaws.com',
        accessKey: AWS_ACCESS_KEY_ID,
        secretKey: AWS_SECRET_ACCESS_KEY,
      },
      http: {
        baseUrl: HTTP_BASE_URL,
        auth: {
          key: HTTP_AUTHORIZATION_KEY,
          defaultValue: HTTP_AUTHORIZATION_DEFAULT_VALUE,
        },
      },
    },
    argo: {
      archiveLogs: as_bool(ARGO_ARCHIVE_LOGS),
      archiveArtifactory: ARGO_ARCHIVE_ARTIFACTORY,
      archiveBucketName: ARGO_ARCHIVE_BUCKETNAME,
      archivePrefix: ARGO_ARCHIVE_PREFIX,
    },
    metadata: {
      envoyService: {
        host: METADATA_ENVOY_SERVICE_SERVICE_HOST,
        port: METADATA_ENVOY_SERVICE_SERVICE_PORT,
      },
    },
    visualizations: {
      allowCustomVisualizations: as_bool(ALLOW_CUSTOM_VISUALIZATIONS),
    },
    viewer: {
      tensorboard: {
        podTemplateSpec: loadJSON<Object | undefined>(VIEWER_TENSORBOARD_POD_TEMPLATE_SPEC_PATH),
      },
    },
    pipeline: {
      host: ML_PIPELINE_SERVICE_HOST,
      port: ML_PIPELINE_SERVICE_PORT,
    },
  };
}

export interface IMinioConfigs {
  accessKey: string;
  secretKey: string;
  endPoint: string;
  port: number;
  useSSL: boolean;
}
export interface IAWSConfigs {
  endPoint: string;
  accessKey: string;
  secretKey: string;
}
export interface IHttpConfigs {
  baseUrl: string;
  auth: {
    key: string;
    defaultValue: string;
  };
}
export interface IPipelineConfigs {
  host: string;
  port: string | number;
}
export interface IViewerConfigs {
  tensorboard: {
    podTemplateSpec?: Object;
  };
}
export interface IVisualizationsConfigs {
  allowCustomVisualizations: boolean;
}
export interface IMetadataConfigs {
  envoyService: {
    host: string;
    port: string | number;
  };
}
export interface IArgoConfigs {
  archiveLogs: boolean;
  archiveArtifactory: string;
  archiveBucketName: string;
  archivePrefix: string;
}
export interface IServerConfigs {
  basePath: string;
  port: string | number;
  staticDir: string;
  apiVersion: string;
  deployment: Deployments;
}
export interface IConfigs {
  server: IServerConfigs;
  artifacts: {
    aws: IAWSConfigs;
    minio: IMinioConfigs;
    http: IHttpConfigs;
  };
  argo: IArgoConfigs;
  metadata: IMetadataConfigs;
  visualizations: IVisualizationsConfigs;
  viewer: IViewerConfigs;
  pipeline: IPipelineConfigs;
}
