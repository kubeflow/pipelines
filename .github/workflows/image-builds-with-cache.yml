name: Build and Cache
on:
  workflow_call:
    outputs:
      IMAGE_PATH:
        description: 'A description of my output'
        value: ${{ jobs.image-build-with-cache.outputs.image_path }}
      IMAGE_TAG:
        description: 'A description of my output'
        value: ${{ jobs.image-build-with-cache.outputs.image_tag }}
      IMAGE_REGISTRY:
        description: 'A description of my output'
        value: ${{ jobs.image-build-with-cache.outputs.registry }}

env:
  IMAGE_TAG: "latest"
  REGISTRY: "kind-registry:5000"
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  GITHUB_SHA: ${{ github.sha }}

jobs:
  image-build-with-cache:
    runs-on: ubuntu-latest
    outputs:
      image_path: ${{ steps.configure.outputs.artifact_path }}
      image_tag: ${{ steps.configure.outputs.image_tag }}
      registry: ${{ steps.configure.outputs.registry }}
    strategy:
      fail-fast: true
      matrix:
        include:
          - image: apiserver
            dockerfile: backend/Dockerfile
            context: .
          - image: persistenceagent
            dockerfile: backend/Dockerfile.persistenceagent
            context: .
          - image: scheduledworkflow
            dockerfile: backend/Dockerfile.scheduledworkflow
            context: .
          - image: launcher
            dockerfile: backend/Dockerfile.launcher
            context: .
          - image: driver
            dockerfile: backend/Dockerfile.driver
            context: .
          - image: frontend
            dockerfile: frontend/Dockerfile
            context: .
          - image: metadata-writer
            dockerfile: backend/metadata_writer/Dockerfile
            context: .
          - image: viewer-crd-controller
            dockerfile: backend/Dockerfile.viewercontroller
            context: .
          - image: visualization-server
            dockerfile: backend/Dockerfile.visualization
            context: .
          - image: cache-deployer
            dockerfile: backend/src/cache/deployer/Dockerfile
            context: .
          - image: cache-server
            dockerfile: backend/Dockerfile.cacheserver
            context: .
          - image: metadata-envoy
            dockerfile: third_party/metadata_envoy/Dockerfile
            context: .
    env:
      ARTIFACT_NAME: "${{ matrix.image }}"
      ARTIFACTS_PATH: "images_${{ github.sha }}"
      BUILDX_MAX_RETRIES: 3
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Create Artifacts Path Directory
        id: configure
        run: |
          mkdir -p ${{ env.ARTIFACTS_PATH }}
          {
            echo "artifact_path=${{ env.ARTIFACTS_PATH }}"
            echo "image_tag=${{ env.IMAGE_TAG }}"
            echo "registry=${{ env.REGISTRY }}"
          } >> "$GITHUB_OUTPUT"

      # Check if the image tarball already exists or not, if yes, then skip building the image
      - name: Check artifact exists
        uses: ./.github/actions/check-artifact-exists
        if: ${{ github.ref_name != github.event.repository.default_branch }}
        with:
          artifact_name: ${{ env.ARTIFACT_NAME }}
        id: artifact-check

      - name: Set up Docker Buildx
        id: setup-buildx
        if: ${{ steps.artifact-check.outputs.exists == 'false' || github.ref_name == github.event.repository.default_branch }}
        shell: bash
        run: |
          BUILDER_NAME="builder-${{ github.run_id }}-${{ github.job }}"
          MAX_RETRIES=${{ env.BUILDX_MAX_RETRIES }}
          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Buildx setup attempt ${attempt}/${MAX_RETRIES} (builder=${BUILDER_NAME})"
            docker buildx rm -f "$BUILDER_NAME" >/dev/null 2>&1 || true
            if ! docker buildx create --use --name "$BUILDER_NAME" --driver docker-container; then
              echo "Buildx create failed (attempt ${attempt}/${MAX_RETRIES})"
            elif ! docker buildx inspect --bootstrap; then
              echo "Buildx bootstrap failed (attempt ${attempt}/${MAX_RETRIES})"
            else
              echo "Buildx setup succeeded (attempt ${attempt}/${MAX_RETRIES})"
              exit 0
            fi
            backoff=$((attempt * 10))
            echo "Buildx setup failed (attempt ${attempt}/${MAX_RETRIES}). Retrying in ${backoff}s..."
            sleep "$backoff"
          done
          exit 1

      - name: Build and save Docker image
        uses: docker/build-push-action@v5
        if: ${{ steps.setup-buildx.outcome == 'success' }}
        id: save-image
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: false
          tags: ${{ env.REGISTRY }}/${{ matrix.image }}:${{ env.IMAGE_TAG }}
          outputs: type=docker,dest=${{ env.ARTIFACTS_PATH }}/${{ env.ARTIFACT_NAME }}.tar

      - name: Rebuild Images in case of failure
        uses: docker/build-push-action@v5
        if: ${{ steps.save-image.outcome != 'success' && steps.setup-buildx.outcome == 'success' }}
        id: rebuild
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: false
          tags: ${{ env.REGISTRY }}/${{ matrix.image }}:${{ env.IMAGE_TAG }}
          outputs: type=docker,dest=${{ env.ARTIFACTS_PATH }}/${{ env.ARTIFACT_NAME }}.tar

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        if: ${{ steps.save-image.outcome == 'success' || steps.rebuild.outcome == 'success' }}
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ env.ARTIFACTS_PATH }}/${{ env.ARTIFACT_NAME }}.tar
          retention-days: 1
        # Continue the workflow even if the upload failed, because upload can fail if other jobs were able to upload artifact first before the current one
        continue-on-error: true
