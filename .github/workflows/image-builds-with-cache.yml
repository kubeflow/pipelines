name: Build and Cache
on:
  workflow_call:
    outputs:
      IMAGE_PATH:
        description: 'A description of my output'
        value: ${{ jobs.image-build-with-cache.outputs.image_path }}
      IMAGE_TAG:
        description: 'A description of my output'
        value: ${{ jobs.image-build-with-cache.outputs.image_tag }}
      IMAGE_REGISTRY:
        description: 'A description of my output'
        value: ${{ jobs.image-build-with-cache.outputs.registry }}

env:
  IMAGE_TAG: "latest"
  REGISTRY: "kind-registry:5000"

jobs:
  image-build-with-cache:
    runs-on: ubuntu-latest
    outputs:
      image_path: ${{ steps.configure.outputs.artifact_path }}
      image_tag: ${{ steps.configure.outputs.image_tag }}
      registry: ${{ steps.configure.outputs.registry }}
    strategy:
      fail-fast: true
      matrix:
        include:
          - image: apiserver
            dockerfile: backend/Dockerfile
            context: .
          - image: persistenceagent
            dockerfile: backend/Dockerfile.persistenceagent
            context: .
          - image: scheduledworkflow
            dockerfile: backend/Dockerfile.scheduledworkflow
            context: .
          - image: launcher
            dockerfile: backend/Dockerfile.launcher
            context: .
          - image: driver
            dockerfile: backend/Dockerfile.driver
            context: .
    env:
      ARTIFACT_NAME: "${{ matrix.image }}"
      ARTIFACTS_PATH: "images_${{ github.sha }}"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create Artifacts Path Directory
        id: configure
        run: |
          mkdir -p ${{ env.ARTIFACTS_PATH }}
          echo "artifact_path=${{ env.ARTIFACTS_PATH }}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ env.IMAGE_TAG }}" >> $GITHUB_OUTPUT
          echo "registry=${{ env.REGISTRY }}" >> $GITHUB_OUTPUT

      # Check if the image tarball already exists or not, if yes, then skip building the image
      - name: Attempt to download the artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ env.ARTIFACTS_PATH }}
        continue-on-error: true
        id: artifact-download

      # If the image tarball was successfully downloaded, then clean it up as the download should
      # happen when image tarballs are actually required for deployment (most likely in a new workflow/job)
      - name: Delete the artifact downloaded artifact
        if: ${{ steps.artifact-download.outcome == 'success' }}
        run: |
          rm -rf ${{ env.ARTIFACTS_PATH }}/${{ env.ARTIFACT_NAME }}
        shell: bash

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        if: ${{ steps.artifact-download.outcome == 'failure' }}
        id: setup-buildx

      - name: Build and save Docker image
        uses: docker/build-push-action@v5
        if: ${{ steps.setup-buildx.outcome == 'success' }}
        id: save-image
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: false
          tags: ${{ env.REGISTRY }}/${{ matrix.image }}:${{ env.IMAGE_TAG }}
          outputs: type=docker,dest=${{ env.ARTIFACTS_PATH }}/${{ env.ARTIFACT_NAME }}.tar

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        if: ${{ steps.save-image.outcome == 'success' }}
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ env.ARTIFACTS_PATH }}/${{ env.ARTIFACT_NAME }}.tar
          retention-days: 1
        # Continue the workflow even if the upload failed, because upload can fail if other jobs were able to upload artifact first before the current one
        continue-on-error: true