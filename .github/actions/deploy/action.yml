name: "Set up KFP on KinD"
description: "Step to start and configure KFP on Kind"

inputs:
  pipeline_store:
    description: "Flag to deploy KFP with K8s Native API"
    default: 'database'
    required: false
  proxy:
    description: "If KFP should be deployed with proxy configuration"
    required: false
    default: 'false'
  cache_enabled:
    description: "If KFP should be deployed with cache enabled globally"
    required: false
    default: 'true'
  image_tag:
    required: true
    description: "Provide the image tag your image was tagged with"
  image_path:
    required: true
    description: "Path within github artifacts where your image tarball is stored"
  image_registry:
    required: true
    description: "Image Registry address of the images"
  multi_user:
    description: "If KFP should be deployed in multi-user mode"
    required: false
    default: 'false'
  artifact_proxy:
    description: "Enables artifact proxy"
    required: false
    default: 'false'
  storage_backend:
    description: "Storage backend to use (minio or seaweedfs)"
    required: false
    default: 'seaweedfs'
  argo_version:
    required: false
    description: "Argo version to use for the cluster"
  forward_port:
    required: false
    default: 'true'
    description: "If you want to forward API server port to localhost:8888"
  pod_to_pod_tls_enabled:
    description: "If KFP should be deployed with TLS pod-to-pod communication."
    required: false
    default: 'false'
  skip_metadata_envoy:
    description: "Skip deploying metadata-envoy (no image required)."
    required: false
    default: 'false'

runs:
  using: "composite"
  steps:
    - name: Deploy Squid
      id: deploy-squid
      if: ${{ inputs.proxy == 'true' }}
      shell: bash
      run: ./.github/resources/squid/deploy-squid.sh

    - name: Download Docker Images
      uses: actions/download-artifact@v6
      with:
        path: "images_${{ github.sha }}"

    - name: Load Docker Images
      shell: bash
      run: |
        APPS=("apiserver" "driver" "launcher" "scheduledworkflow" "persistenceagent" "frontend" "metadata-writer" "viewer-crd-controller" "visualization-server" "cache-deployer" "cache-server" "metadata-envoy"  )
        for app in "${APPS[@]}"; do
          if [[ "${{ inputs.skip_metadata_envoy }}" == "true" && "${app}" == "metadata-envoy" ]]; then
            echo "[deploy] skip_metadata_envoy=true; not loading metadata-envoy image"
            continue
          fi
          tar_path="${{ inputs.image_path }}/$app/$app.tar"
          if [[ ! -f "${tar_path}" ]]; then
            echo "[deploy] ${app} artifact not found; skipping (not built for this lane)"
            continue
          fi
          docker image load -i "${tar_path}"
          docker push ${{ inputs.image_registry }}/$app:${{ inputs.image_tag }}
          rm "${tar_path}"
          docker image rm ${{ inputs.image_registry }}/$app:${{ inputs.image_tag }}
        done  

    - name: Configure Args
      shell: bash
      id: configure
      run: |
        ARGS=""

        if [ "${{ inputs.proxy }}" = "true" ]; then
          echo "Enabling Proxy"
          ARGS="${ARGS} --proxy"
        fi

        if [ "${{inputs.cache_enabled }}" = "false" ]; then
          echo "Disabling Cache"
          ARGS="${ARGS} --cache-disabled"
        fi

        if [ "${{inputs.pipeline_store }}" = "kubernetes" ]; then
          echo "Deploying in native K8s API Mode"
          ARGS="${ARGS} --deploy-k8s-native"
        fi

        if [ "${{ inputs.multi_user }}" = "true" ]; then
          echo "Deploying in Multi User Mode"
          ARGS="${ARGS} --multi-user"
        fi

        if [ "${{ inputs.artifact_proxy }}" = "true" ]; then
          echo "Enabling artifact proxy"
          ARGS="${ARGS} --artifact-proxy"
        fi

        if [ "${{ inputs.storage_backend }}" != "seaweedfs" ] && [ -n "${{ inputs.storage_backend }}" ]; then
          echo "Deploying with artifact storage ${{ inputs.storage_backend }}"
          ARGS="${ARGS} --storage ${{ inputs.storage_backend }}"
        fi

        if [ -n "${{ inputs.argo_version }}" ]; then
          echo "Deploying with argo version ${{ inputs.argo_version }}"
          ARGS="${ARGS} --argo-version ${{ inputs.argo_version }}"
        fi
        if [ "${{inputs.pod_to_pod_tls_enabled }}" = "true" ]; then
          ARGS="${ARGS} --tls-enabled"
        fi
        if [ "${{ inputs.skip_metadata_envoy }}" = "true" ]; then
          echo "Skipping metadata-envoy deployment"
          ARGS="${ARGS} --skip-metadata-envoy"
        fi
        echo "ARGS=$ARGS" >> "$GITHUB_OUTPUT"

    - name: Deploy KFP
      id: deploy-kfp
      if: ${{ steps.configure.outcome == 'success' }}
      uses: nick-fields/retry@ce71cc2ab81d554ebbe88c79ab5975992d79ba08
      with:
        max_attempts: 2
        timeout_minutes: 15
        command: ./.github/resources/scripts/deploy-kfp.sh ${{ steps.configure.outputs.ARGS }}

    - name: Ensure KFP API is reachable
      id: ensure-kfp-api
      shell: bash
      if: ${{ steps.deploy-kfp.outcome == 'success' && inputs.forward_port == 'true'}}
      run: |
        TLS_ENABLED="${{ inputs.pod_to_pod_tls_enabled }}"
        if [ "$TLS_ENABLED" = "true" ] && [ -z "${CA_CERT_PATH:-}" ]; then
          if kubectl get secret kfp-api-tls-cert -n kubeflow >/dev/null 2>&1; then
            kubectl get secret kfp-api-tls-cert -n kubeflow -o jsonpath='{.data.ca\.crt}' | base64 -d > /tmp/kfp-ca.crt
            echo "CA_CERT_PATH=/tmp/kfp-ca.crt" >> "$GITHUB_ENV"
          fi
        fi
        CA_CERT="${CA_CERT_PATH:-}"
        ./.github/resources/scripts/ensure-kfp-api.sh "kubeflow" "ml-pipeline" 8888 "$TLS_ENABLED" "$CA_CERT"
